# Chapter 32. Mastering TDD

## How large should your steps be?
- Automated refactoring accelerates refactoring enormously.

## What don't you have to test?
- "Write tests until fear is transformed into boredom."

## How do you know if you have good tests?
- Long setup code: If you have to spend a hundred lines creating the objects for one simple assertion, then something is wrong. Your objects are too big and need to be split.
- Setup duplication: If you can't easily find a common place for common setup code, then there are too many objects too tightly intertwined.
- Long running tests: TDD tests that run a long time won't be run often, and often haven't been run for a while, and probably don't work. Worse than this, they suggest that testing the bits and pieces of the application is hard. Difficulty testing bits and pieces is a design problem, and needs to be addressed with design. (The equivalent of 9.8 m/s2 is the ten-minute test suite. Suites that take longer than ten minutes inevitably get trimmed, or the application tuned up, so the suite takes ten minutes again.)
- Fragile tests: Tests that break unexpectedly suggest that one part of the application is surprisingly affecting another part. You need to design until the effect at a distance is eliminated, either by breaking the connection or by bringing the two parts together.

## How does TDD lead to frameworks?
- Paradox: by not considering the future of your code, you make your code much more likely to be adaptable in the future.
- The first feature goes in. It is implemented simply and straightforwardly, so it is done quickly and with few defects.
- The second feature, a variation on the first, goes in. The duplication between the two features is put in one place, whereas the differences tend to go in different places (different methods or even different classes).
- The third feature, a variation on the first two, goes in. The common logic is likely to be reusable as is, perhaps with a few tweaks. The unique logic tends to have an obvious home, either in a different method or a different class.

## How much feedback do you need?
- In TDD, the tests are a means to an end - the end being code in which we have great confidence.

## When should you delete tests?
- The first criterion for your tests is confidence. Never delete a test if it reduces your confidence in the behavior of the system.
- The second criterion is communication. If you have two tests that exercise the same path through the code, but they speak to different scenarios for a reader, leave them alone.

## How do the programming language and environment influence TDD?
- In programming languages and environments where TDD cycles are plentiful, you will likely be tempted to try lots more experiments.

## Can you test drive enormous systems?
- By eliminating duplication, you tend to create more smaller objects, and those objects can be tested in isolation independent of the size of the application.

## Can you drive development with application-level tests?
- TDD as described in this book is a technique that is entirely under your control. You can pick it up and start using it today if you so choose.
- Another aspect of ATDD is the length of the cycle between test and feedback.

## How do you switch to TDD midstream?
- First we have to decide to limit the scope of our changes. If we see parts of the system that could be dramatically simplified but that don't demand change at the moment, then we will leave them alone. Shed a tear, perhaps, for the sins of the past, but leave them alone.
- Second, we have to break the deadlock between tests and refactoring. We can get feedback other ways than with tests, like working very carefully and with a partner. We can get feedback at a gross level, like system-level tests that we know aren't adequate but give us some confidence. With this feedback, we can make the areas we have to change more accepting of change.

## How does TDD relate to patterns?
- TDD as an implementation method for pattern-driven design.

## Why does TDD work?
- Part of the effect certainly comes from reducing defects.

## How does TDD relate to the practices of Extreme Programming?
- Pairing, work fresh, continuous integration, simple design, Continuous delivery, and refactoring

## Challenges
- You can't test GUIs automatically
- You can't unit test distributed objects automatically
- You can't test-first develop your database schema 
- There is no need to test third party code or code generated by external tools
- You can't test first develop a language compiler